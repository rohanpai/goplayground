// An example package using Go-as-if-it-had-parametric-polymorphism,
// with an &#34;iter&#34; package in the standard library, following an
// already idiomatic Go iteration pattern.
//
// The feature is entirely imaginary, but I&#39;ve tried to write
// the code to fit as much within Go&#39;s existing idioms as possible.
//
// Generics questions that this code does not attempt to resolve:
//	- What semantics are there for equality of values
//	with parametric types?
//	- what happens if you convert a value with parametric type
//	to an interface?
//
// Points given for pointing out syntax errors, logical inconsistencies
// or language-feature implementation roadtraps.
package main
import (
	&#34;os&#34;
	&#34;log&#34;
	&#34;iter&#34;
)

func main() {
	f, err := os.Open(&#34;/etc/passwd&#34;)
	if err != nil {
		log.Fatal(err)
	}
	r := strings.NewReader(&#34;light blue\nfaded khaki\n&#34;)
	iter0 := iter.BufioScanner(bufio.NewScanner(f))
	iter1 := iter.Slice&lt;string&gt;{&#34;one&#34;, &#34;two&#34;}
	both := iter.Sequence(iter0, iter1)
	prefixed := iter.Map(both, func(s string) string {
		return &#34;x: &#34; &#43; s
	})
	foo, err := iter.Gather(prefixed)
	if err != nil {
		log.Fatal(err)
	}
	// foo is []string{&#34;x: light blue&#34;, &#34;x: faded khaki&#34;, &#34;x: one&#34;, &#34;x: two&#34;}
	fmt.Printf(&#34;%v\n&#34;, foo)
}

///////////////////////////////////////////////////////////

// The iter package implements a general iterator interface type, Iter,
// and some functions that operate on values of that type.
package iter

// Iter represents an iterable collection of values.
type Iter&lt;T&gt; interface {
	// Next advances the iterator to the next value, which will then
	// be available through the Value method. It returns
	// false when the iteration stops, either by reaching the end
	// or an error. After Scan returns false, the Err method
	// will return any error that occurred during iteration..
	Next() bool

	// Value returns the most recent value generated by a call to Next.
	// It may be called any number of times between calls to Next.
	// If called after Next has returned false, it returns the zero value.
	Value() T

	// Err returns the first error encountered.
	Err() error

	// Close closes the iterator and frees any associated resources.
	Close() error
}

// Gather iterates through all the items in iter
// and returns them as a slice.
func Gather&lt;T&gt;(iter Iter&lt;T&gt;) ([]T, error) {
	var slice []T
	while iter.Next() {
		slice = append(slice, iter.Value()
	}
	return slice, iter.Err()
}

// Identity returns the identity function for
// a given type.
func Identity&lt;T&gt;() func(T) T {
	return func(t T) T {
		return t
	}
}

// Map returns an iterator that produces 
// a value f(x) for every value in the given iterator.
// Any non-nil error returned from the underlying iterator
// will be transformed by the given err function.
func Map&lt;S, T&gt;(
	iter Iter&lt;S&gt;,
	transformError func(error) error,
	f func(S) T,
) Iter&lt;T&gt; {
	if transformError == nil {
		transformError = Identity&lt;error&gt;()
	}
	return &amp;mapping{
		Iter: iter,
		f: f,
	}
}

// mapping implements the iterator returned by Map.
// Note the embedding of a type name with
// a parametric type parameter.
// When checking for interface type compatibility,
// methods must be compatible. So if S==T
// then mapping will automatically
// implement Iter&lt;S&gt; but not Iter&lt;T&gt;.
// It will implement interface {
//	Next() bool
//	Close() error
//	Err() error
// }
type mapping&lt;S, T&gt; struct {
	Iter&lt;S&gt;
	f func(S) T
	transformError func(error) error
}

func (m *mapping) Value() bool {
	return m.iter.Next()
}

func (m *mapping) Err() error {
	return m.transformError
}

func BufioScanner(r *bufio.Scanner) Iter&lt;string&gt; {
	return bufioScanner(r)
}

type bufioScanner struct {
	r *bufio.Scanner
}

func (b bufioScanner) Next() bool {
	return b.r.Scan()
}

func (b bufioScanner) Err() error {
	return b.r.Err()
}

func (b bufioScanner) Value() string {
	return b.r.Text()
}

func (b bufioScanner) Close() error {
	return nil
}

type slice&lt;T&gt; struct {
	first bool
	values []T
}

// Slice implements Iter on a slice.
// The values are traversed from beginning to end.
func NewSlice&lt;T&gt;(values []T) Iter&lt;T&gt; {
	return &amp;slice{
		first: true,
		values: values,
	}
}

func (s *slice) Next() bool {
	if s.first {
		s.first = false
	} else {
		s.values = s.elems[1:]
	}
	return len(s.values) &gt; 0
}

func (s *slice) Err() error {
	return nil
}

func (s *slice) Close() error {
	return nil
}

func (s *slice) Value() s.T {
	return s.values[0]
}


// Sequence returns an iterator that iterates
// through each of the given iterators in turn.
// The first error will terminate any remaining
// iterators. All are closed in turn when or before
// the returned iterator is closed.
//
func Sequence(iters ...Iter&lt;T&gt;) Iter&lt;T&gt; {
	return &amp;sequence{
		iters: iters,
	}
}

type sequence struct&lt;T&gt; {
	iters []Iter&lt;T&gt;
	err error
}

func (s *sequence) Next() bool {
	for len(s.iters) &gt; 0 {
		iter := s.iters[0]
		if iter.Next() {
			return true
		}
		if err := iter.Err(); err != nil {
			s.err = err
			s.Close()
			s.iters = nil
			return false
		}
		s.iters = s.iters[1:]
	}
	return false
}

func (s *sequence) Err() error {
	if s.err != nil {
		return s.err
	}
	if len(s.iters) &gt; 0 {
		s.err = s.iters[0].Err()
		return s.err
	}
	return nil
}

func (s *sequence) Value() s.T {
	if len(s.iters) == 0 {
		// Note the use of &#34;zero&#34; here, as a more
		// general form of &#34;nil&#34; that is a valid
		// zero value for any type, not just pointers.
		return zero
	}
	return s.iters[0].Value()
}

func (s *sequence) Close() error {
	var closeErr error
	for len(s.iters) &gt; 0 {
		if err := s.iters[0].Close(); err != nil &amp;&amp; closeErr == nil {
			closeErr = err
		}
		s.iters = s.iters[1:]
	}
	return closeErr
}

// Concurrent returns a channel reading the
// results of al the given iterators running
// concurrently.
func Concurrent&lt;T&gt;(iters ...Iter&lt;T&gt;) chan T {
	c := make(chan T)
	go func() {
		var wg sync.WaitGroup
		for _, iter := range iters {
			iter := iter
			go func() {
				defer wg.Done()
				defer iter.Close()
				for iter.Next() {
					c &lt;- iter.Value()
				}
			}()
		}
		wg.Wait()
		close(c)
	}()
	return c
}
