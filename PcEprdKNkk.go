// _Срезы_ ключевой тип данных в Go, дающий
// более мощный интерфейс для работы
// с последовательностями, чем _массивы_.

package main

import &#34;fmt&#34;

func main() {

    // Срез это часть массива. Как и массивы
    // срезы индексируются и имеют длину.
    // В отличии от массивов, их длину можно изменить.
    // Для создания пустого среза с не нулевой длиной
    // воспользуйтесь встроенной функцией `make`.
    // В этом примере мы создали срез из `строк`
    // с размером среза в 3 элемента (инициализированных
    // нулевыми значениями).
    s := make([]string, 3)
    fmt.Println(&#34;emp:&#34;, s)

    // Установка и чтение значений происходит точно также как в массиве.
    s[0] = &#34;a&#34;
    s[1] = &#34;b&#34;
    s[2] = &#34;c&#34;
    fmt.Println(&#34;set:&#34;, s)
    fmt.Println(&#34;get:&#34;, s[2])

    // `len` возвращает размер среза.
    fmt.Println(&#34;len:&#34;, len(s))

    // В дополнение к этим базовым функциям,
    // срезы поддерживают несколько других функций
    // которые делают их возможности гораздо шире
    // чем у массивов. Одна из них - это `append`,
    // которая возвращает срез содержащий 1 или более
    // новых значений. Обратите внимание, что мы должны
    // принять возвращаемое функцией `append` значение -
    // таким образом мы получаем новое значение среза.
    s = append(s, &#34;d&#34;)
    s = append(s, &#34;e&#34;, &#34;f&#34;)
    fmt.Println(&#34;apd:&#34;, s)

    // Срезы можно копировать. В этом примере мы создали
    // пустой срез `c` той же самой длины что и `s` и
    // скопировали содержимое из `s` в `c`.
    c := make([]string, len(s))
    copy(c, s)
    fmt.Println(&#34;cpy:&#34;, c)

    // Срезы поддерживают &#34;slice&#34;-оператор с синтаксисом
    // `slice[low:high]`. Например, здесь мы получаем
    // срез элементов `s[2]`, `s[3]`, и `s[4]`.
    l := s[2:5]
    fmt.Println(&#34;sl1:&#34;, l)

    // Здесь делается срез элементов от `s[0]`
    // до `s[5]` (но исключая).
    l = s[:5]
    fmt.Println(&#34;sl2:&#34;, l)

    // А это срез начиная с элемента `s[2]` (включительно)
    // и до конца среза.
    l = s[2:]
    fmt.Println(&#34;sl3:&#34;, l)

    // Мы можем объявить и инициализировать переменную
    // для `среза` в одну строку.
    t := []string{&#34;g&#34;, &#34;h&#34;, &#34;i&#34;}
    fmt.Println(&#34;dcl:&#34;, t)

    // Срезы могут быть составлены в многомерные структуры
    // данных. В отличии от многомерных массивов,
    // размер внутренних срезов может различаться.
    twoD := make([][]int, 3)
    for i := 0; i &lt; 3; i&#43;&#43; {
        innerLen := i &#43; 1
        twoD[i] = make([]int, innerLen)
        for j := 0; j &lt; innerLen; j&#43;&#43; {
            twoD[i][j] = i &#43; j
        }
    }
    fmt.Println(&#34;2d: &#34;, twoD)
}
