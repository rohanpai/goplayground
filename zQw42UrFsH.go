// Ключевое слово package присутствует в начале каждого файла
// main — специальное имя, обозначает исполняемый файл, нежели библиотеку
package main

// import указывает зависимости этого пакета.
import (
	&#34;fmt&#34;      // Пакет в stdlib
	&#34;net/http&#34; // Веб-сервер
	&#34;strconv&#34;  // Конвертирование типов в строки и обратно
)

// func — объявление ф-ции
// main — спец. ф-ция, является точкой входа для исполняемой программы
func main() {
	// Println выводит строку в stdout
	// В данном случае фигурирует вызов ф-ции из пакета fmt
	fmt.Println(&#34;Hello, world!&#34;)

	// Вызов другой ф-ции из текущего пакета
	beyondHello()
}

// Ф-ции содержат входные параметры в круглых скобках
// Пустые скобки всё равно обязательны, даже без параметров
func beyondHello() {
	var x int // переменные должны быть объявлены до их использования
	x = 3     // присвоение значения переменной

	// Краткое объявление := позволяет инициализировать переменную
	// с автоподстановкой типа из её значения
	y := 4
	sum, prod := learnMultiple(x, y)        // ф-ция возвращает 2 значения
	fmt.Println(&#34;sum:&#34;, sum, &#34;prod:&#34;, prod) // простой вывод

	learnTypes() // &lt; y minutes, learn more!
}

// Ф-ция имеет входные параметры и возвращает несколько значений
func learnMultiple(x, y int) (sum, prod int) {
	return x &#43; y, x * y // возврат двух результатов
}

// Некоторые встроенные типы и литералы
func learnTypes() {
	// Краткое объявление переменной говорит само за себя
	s := &#34;Learn Go!&#34; // тип string

	s2 := `&#34;Чистый&#34; строковый литерал
        может содержать переносы строк` // тип данных тот же, string

	// Символ не из ASCII
	// Исходный код Go в кодировке UTF-8
	g := &#39;Σ&#39;     // тип rune, это алиас для типа uint32, содержит юникод символ
	f := 3.14195 // float64, 64-х битное число с плавающей точкой (IEEE-754)
	c := 3 &#43; 4i  // complex128, внутри себя содержит два float64

	// Синтаксис var c инициализациями
	var u uint = 7 // беззнаковое, но размер зависит от реализации, как и у int
	var pi float32 = 22. / 7

	// Синтаксис приведения типа с кратким определением
	n := byte(&#39;\n&#39;) // byte алиас для uint8

	// Массивы (Array) имеют фиксированный размер на момент компиляции
	var a4 [4]int           // массив из 4-х int, проинициализирован нулями
	a3 := [...]int{3, 1, 5} // массив из 3-х int, ручная инициализация

	// Slice имеют динамическую длину.
	// И массивы и slice-ы имеют каждый свои преимущества, но slice-ы используются гораздо чаще
	s3 := []int{4, 5, 9}    // по сравнению с a3 тут нет троеточия
	s4 := make([]int, 4)    // выделение памяти для slice из 4-х int (нули)
	var d2 [][]float64      // только объявление, память не выделяется
	bs := []byte(&#34;a slice&#34;) // конвертирование строки в slice байтов
	p, q := learnMemory()   // объявление p и q как указателей на int
	fmt.Println(*p, *q)     // * извлекает указатель. Печатает два int-а

	// map как словарь или хеш таблица из других яп является
	// ассоциативным массивом с динамически изменяемым размером
	m := map[string]int{&#34;three&#34;: 3, &#34;four&#34;: 4}
	m[&#34;one&#34;] = 1
	delete(m, &#34;three&#34;) // встроенная ф-ция, удаляет элемент из map-а

	// Неиспользуемые переменные в Go являются ошибкой
	// Нижнее подчеркивание позволяет игнорировать такие переменные
	_, _, _, _, _, _, _, _, _ = s2, g, f, u, pi, n, a3, s4, bs

	// Вывод считается использованием переменной
	fmt.Println(s, c, a4, s3, d2, m)

	learnFlowControl()
}

// У Go есть полноценный сборщик мусора. В нём есть указатели, но нет арифметики указателей
// Вы можете допустить ошибку с указателем на nil, но не с его инкрементацией
func learnMemory() (p, q *int) {
	// Именованные возвращаемые значения p и q являются указателями на int
	p = new(int) // встроенная ф-ция new выделяет память

	// Выделенный int принициализирован нулём, p больше не содержит nil
	s := make([]int, 20) // выделение единого блока памяти под 20 int-ов,
	s[3] = 7             // назначение одному из них,
	r := -2              // определение ещё одной локальной переменной,
	return &amp;s[3], &amp;r     // амперсанд обозначает получение адреса переменной
}

func expensiveComputation() {
	return 1e6
}

func learnFlowControl() {
	// if-ы всегда требуют наличие фигурных скобок, но круглые скобки необязательны
	if true {
		fmt.Println(&#34;told ya&#34;)
	}

	// Форматирование кода стандартизировано утилитой &#34;go fmt&#34;
	if false {
		// всё тлен
	} else {
		// жизнь прекрасна
	}

	// Использование switch на замену нескольким if-else
	x := 1
	switch x {
	case 0:
	case 1:
		// case-ы в Go не проваливаются, т.е. break по умолчанию
	case 2:
		// не выполнится
	}

	// for — единственный цикл в Go, но у него несколько форм
	for { // бесконечный цикл
		break    // не такой уж и бесконечный
		continue // не выполнится
	}

	// Как и в for, := в if-e означает объявление и присвоение значения y,
	// затем проверка y &gt; x
	if y := expensiveComputation(); y &gt; x {
		x = y
	}

	// Ф-ции являются замыканиями
	xBig := func() bool {
		return x &gt; 100 // ссылается на x, объявление выше switch
	}
	fmt.Println(&#34;xBig:&#34;, xBig()) // true (т.к. мы присвоили x = 1e6)
	x /= 1e5                     // тут x == 10
	fmt.Println(&#34;xBig:&#34;, xBig()) // теперь false

	// Метки
	goto love
love:

	learnInterfaces() // Интерфейсы, идём дальше
}

// Объявление Stringer как интерфейса с одним методом, String
type Stinger interface {
	String() string
}

// Объявление pair как структуры с двумя полями x и y типа int
type pair struct {
	x, y int
}

// Объявление метода для типа pair. Теперь pair реализует интерфейс Stringer
func (p pair) String() string { // p в данном случае называют receiver-ом
	// Sprintf — ещё одна ф-ция из пакета fmt
	// Обращение к полям p через точку
	return fmt.Sprintf(&#34;(%d, %d)&#34;, p.x, p.y)
}

func learnInterfaces() {
	// Синтаксис с фигурным скобками это &#34;литерал структуры&#34;
	// Он возвращает проинициализированную структуру, а оператор := присваивает её в p
	p := pair{3, 4}
	fmt.Println(p.String()) // вызов метода String у p, типа pair
	var i Stringer          // объявление i как типа с интерфейсом Stringer
	i = p                   // валидно, т.к. pair реализует Stringer

	// Вызов метода String y i, типа Stringer. Вывод такой же что и выше
	fmt.Println(i.String())

	// Ф-ция в пакете fmt сами всегда вызывают метод String у объектов
	// для получание строкового представления о них
	fmt.Println(p) // вывод такой же что и выше. Println вызывает метод String
	fmt.Println(i) // тоже самое

	learnErrorHandling()
}

func learnErrorHandling() {
	// Идиома &#34;, ok&#34; служит для обозначения сработало что-то или нет
	m := map[int]string{3: &#34;three&#34;, 4: &#34;four&#34;}
	if x, ok := m[1]; !ok { // ok будет false, потому что 1 нет в map-e
		fmt.Println(&#34;тут никого&#34;)
	} else {
		fmt.Print(x) // x содержал бы значение, если бы 1 был в map-e
	}

	// Идиома &#34;, err&#34; служит для обозначения была ли ошибка или нет
	if _, err := strconv.Atoi(&#34;non-int&#34;); err != nil { // _ игнорирует значение
		// выведет &#34;strconv.ParsrInt: parsing &#34;non-int&#34;: invalid syntax&#34;
		fmt.Println(err)
	}

	learnConcurrency()
}

// c — тип данных channel (канал), объект для конкуррентного взаимодействия
func inc(i int, c chan int) {
	с &lt;- i &#43; 1 // когда channel слева, &lt;- является оператором &#34;отправки&#34;
}

// Будем использовать ф-цию inc для конкуррентной инкрементации чисел
func learnConcurrency() {
	// Тот же make, что и в случае со slice.
	// Он предназначен для выделения памяти и инициализации типов slice, map и channel
	с := make(chan int)

	// Старт трёх конкуррентных goroutine. Числа будут инкрементированы конкуррентно и,
	// может быть параллельно, если машина правильно сконфигурирована и позволяет это делать
	// Все они будут отправлены в один и тот же канал
	go inc(0, c) // go начинает новую горутину
	go inc(10, c)
	go inc(-805, c)

	// Считывание всех трёх результатов из канала и вывод на экран
	// Нет никакой гарантии в каком порядке они будут выведены
	fmt.Println(&lt;-c, &lt;-c, &lt;-c)   // Канал справа, &lt;- обозначает &#34;получение&#34;
	cs := make(chan string)      // другой канал, содержит строки
	cc := make(chan chan string) // канал каналов со строками
	go func() { c &lt;- 84 }()      // пуск новой горутины для отправки значения
	go func() { cs &lt;- &#34;wody&#34; }() // ещё раз, теперь для cs

	// select тоже что и switch, но работает с каналами
	// Он случайно выбирает готовый для взаимодействия канал
	select {
	case i := &lt;-c: // полученное значение можно присвоаить переменной
		fmt.Printf(&#34;это %T&#34;, i)
	case &lt;-cs: // либо значение можно ингнорировать
		fmt.Println(&#34;это строка&#34;)
	case &lt;-cc: // пустой канал, не готов для коммуникации
		fmt.Println(&#34;это не выполнится.&#34;)
	}

	learnWebProgramming()
}

// Всего одна ф-ция из пакета http запускает веб-сервер
func learnWebProgramming() {
	// У ListenAndServe первый параметр это TCP адрес, который нужно слушать
	// Второй — интерфейс типа http.Handler
	err := http.ListenAndServe(&#34;:8080&#34;, pair{})
	fmt.Println(err) // не игнорируйте сообщения об ошибках
}

// Реализация интерфейса http.Handler для pair, только один метод ServeHTTP
func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Обработка запроса и отправка данных методом из http.ResponseWriter
	w.Write([]byte(&#34;You learned Go in Y minutes&#34;))
}
